import * as React from 'react';
import type { PartialImageDocument } from '@vibes.diy/use-vibes-types';
import { useFireproof, ImgFile, Database } from 'use-fireproof';
import { ImgGenFileDrop } from '../ImgGenUtils/ImgGenFileDrop.js';
import { ImgGenClasses, combineClasses } from '../../utils/style-utils.js';
import { imgGenStyles, imgGenTheme } from '../../utils/styles.js';

interface ImgGenUploadWaitingProps {
  /** Document with uploaded files (optional) */
  readonly document?: PartialImageDocument;
  /** Classname(s) to apply to the container */
  readonly className?: string;
  /** Custom CSS classes for styling component parts */
  readonly classes?: Partial<ImgGenClasses>;
  /** Enable debugging output */
  readonly debug?: boolean;
  /** Database name or instance to use for storing images */
  readonly database?: string | Database;
  /** Callback when new files are uploaded to this document */
  readonly onFilesAdded?: () => void;
  /** Callback when document is created from file uploads */
  readonly onDocumentCreated?: (docId: string) => void;
  /** Callback when prompt is set and generation should begin */
  readonly onPromptSubmit: (prompt: string, documentId?: string) => void;
}

/**
 * Component for displaying uploaded images and allowing users to:
 * 1. Upload more images to the same document
 * 2. Enter a prompt to start generation
 */
export function ImgGenUploadWaiting({
  document,
  className,
  classes,
  debug,
  database,
  onFilesAdded,
  onDocumentCreated,
  onPromptSubmit,
}: ImgGenUploadWaitingProps): React.ReactElement {
  const { database: db } = useFireproof(database || 'ImgGen');
  const [prompt, setPrompt] = React.useState('');
  const [inputFiles, setInputFiles] = React.useState<string[]>([]);

  // Get all input files from the document
  React.useEffect(() => {
    if (document?._files) {
      const inFiles = Object.keys(document._files)
        .filter((key) => key.startsWith('in'))
        .sort();

      setInputFiles(inFiles);

      if (debug) {
        console.log('[ImgGenUploadWaiting] Found input files:', inFiles);
      }
    }
  }, [document, debug]);

  // Clean up any created object URLs when unmounting
  React.useEffect(() => {
    const objectUrls: string[] = [];

    return () => {
      // Clean up any created object URLs

      objectUrls.forEach((url) => URL.revokeObjectURL(url));
    };
  }, []);

  // Handle files being uploaded - two paths: add to existing doc or create new doc
  const handleFilesUploaded = async (files: File[]) => {
    if (!files.length) return;

    // If we already have a document, add files to it
    if (document && document._id) {
      await addFilesToExistingDocument(files);
    }
    // Otherwise create a new document
    else {
      await createNewDocumentWithFiles(files);
    }
  };

  // Create a new document with the uploaded files
  const createNewDocumentWithFiles = async (files: File[]) => {
    try {
      // Create new document to hold the uploaded files
      const newDoc = {
        type: 'image',
        createdAt: new Date().toISOString(),
        _files: {} as Record<string, File>,
      };

      // Add files to the document with input file keys
      files.forEach((file, index) => {
        // Input files are prefixed with 'in' followed by a number
        // These are files uploaded by the user, not generated by AI
        newDoc._files[`in${index + 1}`] = file;
      });

      // Save the document to get an ID
      const result = await db.put(newDoc);

      if (debug) {
        console.log('[ImgGenUploadWaiting] Created document for uploads:', result.id);
      }

      // Notify parent component that files were uploaded and document created
      if (onDocumentCreated && result.id) {
        onDocumentCreated(result.id);
      }
    } catch (error) {
      console.error('[ImgGenUploadWaiting] Error creating document for uploads:', error);
    }
  };

  // Add files to an existing document
  const addFilesToExistingDocument = async (files: File[]) => {
    if (!document || !document._id) return;

    try {
      // Load existing document
      const doc = await db.get(document._id);
      if (!doc) {
        console.error('[ImgGenUploadWaiting] Document not found:', document._id);
        return;
      }

      // Find highest current input file number
      let maxInputNum = 0;
      if (doc._files) {
        Object.keys(doc._files).forEach((key) => {
          if (key.startsWith('in')) {
            const num = parseInt(key.substring(2), 10);
            if (!isNaN(num) && num > maxInputNum) {
              maxInputNum = num;
            }
          }
        });
      }

      // Add new files with incremented keys
      const updatedDoc = { ...doc };
      if (!updatedDoc._files) updatedDoc._files = {};

      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileKey = `in${maxInputNum + i + 1}`;

        // Add file to document
        updatedDoc._files[fileKey] = file;

        if (debug) {
          console.log(`[ImgGenUploadWaiting] Adding file to document: ${fileKey}`, file.name);
        }
      }

      // Save updated document
      const result = await db.put(updatedDoc);

      if (debug) {
        console.log('[ImgGenUploadWaiting] Document updated with new files:', result.id);
      }

      // Refresh the document to get the latest version with new files
      const refreshedDoc = await db.get(result.id);
      if (refreshedDoc) {
        // Update input files state with the new files
        const inFiles = Object.keys(refreshedDoc._files || {})
          .filter((key) => key.startsWith('in'))
          .sort();

        setInputFiles(inFiles);

        if (debug) {
          console.log('[ImgGenUploadWaiting] Refreshed input files:', inFiles);
        }
      }

      // Notify parent about files added
      if (onFilesAdded) {
        onFilesAdded();
      }
    } catch (error) {
      console.error('[ImgGenUploadWaiting] Error updating document with new files:', error);
    }
  };

  // Handle prompt submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (prompt.trim()) {
      // Pass both the prompt and document ID to the parent component if we have a document
      if (document && document._id) {
        if (debug) {
          console.log('[ImgGenUploadWaiting] Submitting prompt with document ID:', document._id);
        }
        onPromptSubmit(prompt.trim(), document._id);
      } else {
        // Submit just the prompt if no document is available
        if (debug) {
          console.log('[ImgGenUploadWaiting] Submitting prompt with no document');
        }
        onPromptSubmit(prompt.trim());
      }
    }
  };

  // We no longer need this function since we're using ImgFile component
  // which handles all the file display logic for us

  return (
    <div
      className={combineClasses(
        'imggen-upload-waiting',
        className || '',
        classes?.uploadWaiting || ''
      )}
      style={imgGenStyles.uploadWaiting}
    >
      {/* Page title and description */}
      <div className="imggen-placeholder-content" style={{ textAlign: 'center' }}>
        <h3 style={{ margin: '0 0 0.5rem 0', color: imgGenTheme.colors.titleText }}>
          Image Generator
        </h3>
      </div>
      <p style={{ color: imgGenTheme.colors.titleText }}>No prompt or file provided</p>
      {/* Prompt input form */}
      <form onSubmit={handleSubmit} className="imggen-prompt-form" style={imgGenStyles.promptForm}>
        <input
          type="text"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Enter a prompt..."
          className="imggen-prompt-input"
          style={imgGenStyles.promptInput}
        />
        <button
          type="submit"
          disabled={!prompt.trim()}
          className="imggen-prompt-submit"
          style={{
            ...imgGenStyles.promptSubmit,
            opacity: !prompt.trim() ? 0.5 : 1,
            cursor: !prompt.trim() ? 'not-allowed' : 'pointer',
          }}
        >
          Generate
        </button>
      </form>

      {/* Display thumbnails of uploaded files - only if we have files */}
      {inputFiles.length > 0 && (
        <div className="imggen-uploaded-previews" style={imgGenStyles.uploadedPreviews}>
          <div className="imggen-upload-count" style={imgGenStyles.uploadCount}>
            {inputFiles.length} {inputFiles.length === 1 ? 'image' : 'images'} uploaded
          </div>
          <div className="imggen-thumbnails" style={imgGenStyles.thumbnails}>
            {inputFiles.slice(0, 4).map((fileKey) => (
              <div key={fileKey} className="imggen-thumbnail" style={imgGenStyles.thumbnail}>
                {document?._files && document._files[fileKey] && (
                  <ImgFile
                    file={document._files[fileKey]}
                    alt={`Upload ${fileKey}`}
                    className="imggen-thumbnail-img"
                    style={imgGenStyles.thumbnailImg}
                  />
                )}
              </div>
            ))}
            {inputFiles.length > 4 && (
              <div className="imggen-more-count" style={imgGenStyles.moreCount}>
                +{inputFiles.length - 4} more
              </div>
            )}
          </div>
        </div>
      )}

      {/* Drop zone for more files */}
      <ImgGenFileDrop
        className={classes?.dropZone || ''}
        onFilesDropped={handleFilesUploaded}
        isActive={true}
        maxFiles={10}
        debug={debug}
        addFilesMessage="Drop images or click to upload (optional)"
      />
    </div>
  );
}
